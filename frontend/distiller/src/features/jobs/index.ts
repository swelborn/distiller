import {
  createAsyncThunk,
  createSlice,
  createEntityAdapter,
  PayloadAction,
  createSelector,
} from '@reduxjs/toolkit';
import { RootState } from '../../app/store';
import {
  getJobs as getJobsAPI,
  getJob as getJobAPI,
  patchJob as patchJobAPI,
  cancelJob as cancelJobAPI,
} from './api';
import { getScanJobs as getScanJobsAPI } from '../scans/api';
import {
  Job,
  IdType,
  JobsRequestResult,
  JobType,
  PendingJobStates,
  RunningJobStates,
} from '../../types';
import { DateTime } from 'luxon';

export const jobsAdapter = createEntityAdapter<Job>();

export interface JobsState
  extends ReturnType<(typeof jobsAdapter)['getInitialState']> {
  status: 'idle' | 'loading' | 'complete';
  totalCount: number;
  fetchedJobIds: IdType[];
  sessionJobId: IdType | null;
}

const initialState: JobsState = jobsAdapter.getInitialState({
  status: 'idle',
  totalCount: -1,
  fetchedJobIds: [] as IdType[],
  sessionJobId: null,
});

export const getJobs = createAsyncThunk<
  JobsRequestResult,
  {
    skip: number;
    limit: number;
    jobType?: JobType;
    start?: DateTime;
    end?: DateTime;
  }
>('jobs/fetch', async (_payload, _thunkAPI) => {
  const { skip, limit, jobType, start, end } = _payload;
  const result = await getJobsAPI(skip, limit, jobType, start, end);

  return result;
});

export const getJob = createAsyncThunk<Job, { id: IdType }>(
  'job/fetch',
  async (payload, _thunkAPI) => {
    const { id } = payload;
    const job = await getJobAPI(id);

    return job;
  }
);

export const getScanJobs = createAsyncThunk<
  Job[],
  {
    scanId: IdType;
  }
>('jobs/fetchByScanId', async (payload, _thunkAPI) => {
  const { scanId } = payload;
  const jobs = await getScanJobsAPI(scanId);

  return jobs;
});

export const patchJob = createAsyncThunk<
  Job,
  { id: IdType; updates: Partial<Job> }
>('jobs/patch', async (payload, _thunkAPI) => {
  const { id, updates } = payload;
  const job = await patchJobAPI(id, updates);

  return job;
});

export const cancelJob = createAsyncThunk<Job, { id: IdType }>(
  'jobs/delete',
  async (payload, _thunkAPI) => {
    const { id } = payload;
    const job = await cancelJobAPI(id);
    return job;
  }
);

export const jobsSlice = createSlice({
  name: 'jobs',
  initialState,
  reducers: {
    setJob(state, action: PayloadAction<Job>) {
      state.totalCount = state.totalCount + 1;
      jobsAdapter.setOne(state, action.payload);
      state.ids = state.ids.sort((a, b) => Number(b) - Number(a)); // sort ids in descending order
    },
    updateJob(state, action: PayloadAction<Partial<Job>>) {
      const { id, ...changes } = action.payload;
      if (id !== undefined) {
        jobsAdapter.updateOne(state, { id, changes });
      }
    },
    addFetchedJobId(state, action: PayloadAction<IdType>) {
      if (!state.fetchedJobIds.includes(action.payload)) {
        state.fetchedJobIds.push(action.payload);
      }
    },
    setSessionJobId(state, action: PayloadAction<IdType>) {
      state.sessionJobId = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getJobs.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(getJobs.rejected, (state) => {
        state.status = 'idle';
      })
      .addCase(getJobs.fulfilled, (state, action) => {
        const { totalCount, jobs } = action.payload;
        state.status = 'complete';
        state.totalCount = totalCount;
        jobsAdapter.upsertMany(state, jobs);
      })
      .addCase(getJob.fulfilled, (state, action) => {
        const job = action.payload;
        jobsAdapter.upsertOne(state, job);
      })
      .addCase(getScanJobs.fulfilled, (state, action) => {
        const jobs = action.payload;
        jobsAdapter.upsertMany(state, jobs);
      })
      .addCase(patchJob.fulfilled, (state, action) => {
        const update = {
          id: action.payload.id,
          changes: action.payload,
        };
        jobsAdapter.updateOne(state, update);
      });
  },
});

export const jobsSelector = jobsAdapter.getSelectors<RootState>(
  (state) => state.jobs
);

const jobState = (rootState: RootState) => rootState.jobs;

const { selectById, selectAll } = jobsAdapter.getSelectors();
export const jobSelector = (id: IdType) => {
  return createSelector(jobState, (state) => selectById(state, id));
};

export const allJobsSelector = createSelector(jobState, selectAll);

export const jobsByScanIdSelector = (scanId: IdType) => {
  return createSelector(jobState, (state) => {
    return Object.values(state.entities).filter(
      (job): job is Job =>
        job !== undefined && job.scanIds && job.scanIds.includes(scanId)
    );
  });
};

export const jobsExistInStore = (state: RootState, jobIds: IdType[]) => {
  const jobsInState = jobIds.map((id) =>
    jobsAdapter.getSelectors().selectById(state.jobs, id)
  );
  return jobsInState.every((job) => job !== undefined);
};

export const selectJobsByPage = (
  page: number,
  itemsPerPage: number,
  jobType: JobType | null
) => {
  return createSelector(jobState, (state) => {
    const start = page * itemsPerPage;
    const end = start + itemsPerPage;
    const pageIds = state.ids.slice(start, end);

    let jobs = pageIds
      .map((id) => state.entities[id]!)
      .filter((job) => job !== undefined);

    // If jobType is defined, filter jobs by job type
    if (jobType) {
      jobs = jobs.filter((job) => job.job_type === jobType);
    }

    return jobs;
  });
};

export const selectJobsByDate = (
  startDateFilter: DateTime | null,
  endDateFilter: DateTime | null,
  jobType: JobType | null
) => {
  return createSelector(
    [jobState, (state: RootState) => state],
    (jobsState, state) => {
      let jobs = Object.values(jobsState.entities) as Job[];

      // If both filters are null, return all jobs
      if (!startDateFilter && !endDateFilter && !jobType) {
        return jobs;
      }

      // If start date is defined, filter jobs submitted after start date
      if (startDateFilter) {
        jobs = jobs.filter(
          (job) => job.submit && DateTime.fromISO(job.submit) >= startDateFilter
        );
      }

      // If end date is defined, filter jobs submitted before end date
      if (endDateFilter) {
        jobs = jobs.filter(
          (job) => job.submit && DateTime.fromISO(job.submit) <= endDateFilter
        );
      }

      // If jobType is defined, filter jobs by job type
      if (jobType) {
        jobs = jobs.filter((job) => job.job_type === jobType);
      }

      return jobs;
    }
  );
};

export const anyStreamingJobsSelector = createSelector(
  jobState, // get jobState
  (state) => {
    // Current date
    const now = DateTime.local();
    // One day ago
    const oneDayAgo = now.minus({ days: 1 });

    // Return true if any job matches the conditions
    return Object.values(state.entities).some((job) => {
      if (job && job.state) {
        // Check if job type is streaming
        if (job.job_type === JobType.Streaming) {
          // Check if job is in pending or running state
          if (
            (PendingJobStates.has(job.state) && job.slurm_id) ||
            RunningJobStates.has(job.state)
          ) {
            // Check if job is submitted within the past day
            if (job.submit && DateTime.fromISO(job.submit) >= oneDayAgo) {
              return true; // this job matches all the conditions
            }
          }
        }
      }
      return false; // this job doesn't match all the conditions
    });
  }
);

export const fetchedJobIdsSelector = (state: RootState) =>
  state.jobs.fetchedJobIds;

export const totalCount = (state: RootState) => state.jobs.totalCount;

export const { setJob, updateJob, addFetchedJobId, setSessionJobId } =
  jobsSlice.actions;

export default jobsSlice.reducer;
